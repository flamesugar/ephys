<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ss_align</title>
  <meta name="keywords" content="ss_align">
  <meta name="description" content="UltraMegaSort2000 by Hill DN, Mehta SB, &amp; Kleinfeld D  - 07/12/2010">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">spike_sorting</a> &gt; ss_align.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for spike_sorting&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>ss_align
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>UltraMegaSort2000 by Hill DN, Mehta SB, &amp; Kleinfeld D  - 07/12/2010</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function spikes = ss_align( spikes ) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> UltraMegaSort2000 by Hill DN, Mehta SB, &amp; Kleinfeld D  - 07/12/2010

 ss_align - Multi-channel alignment of waveforms on negative peaks

 Usage:
       spikes = ss_align( spikes )

 Description:  
   This function uses spline interpolation in order to find the true peak
 of the event waveforms in a spikes object.  The threshold crossing used
 in spike detection may not be an optimal location for aligning spikes 
 because (1) finite sampling by a data acquisition card may not capture
 the true moment of threshold crossing and (2) the threshold crossing
 is susceptible to noise. So we use alignment in order to compare spikes
 aligned on their maximum negative deviation from 0.

 Alignment is performed on the channel with the largest deviation and then
 this offset is applied to all other channels.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="RunAutoClass.html" class="code" title="function TANKS = RunAutoClass(TANKS)">RunAutoClass</a>	RunAutoClass</li><li><a href="SCRATCH_AutoClass2.html" class="code" title="">SCRATCH_AutoClass2</a>	% AutoClass Scratch</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function shifts = get_offsets( w2, thresh_sample, max_samples )</a></li><li><a href="#_sub2" class="code">function new_w = respline(w,  shifts, max_s)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function spikes = ss_align( spikes )</a>
0002 <span class="comment">% UltraMegaSort2000 by Hill DN, Mehta SB, &amp; Kleinfeld D  - 07/12/2010</span>
0003 <span class="comment">%</span>
0004 <span class="comment">% ss_align - Multi-channel alignment of waveforms on negative peaks</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Usage:</span>
0007 <span class="comment">%       spikes = ss_align( spikes )</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% Description:</span>
0010 <span class="comment">%   This function uses spline interpolation in order to find the true peak</span>
0011 <span class="comment">% of the event waveforms in a spikes object.  The threshold crossing used</span>
0012 <span class="comment">% in spike detection may not be an optimal location for aligning spikes</span>
0013 <span class="comment">% because (1) finite sampling by a data acquisition card may not capture</span>
0014 <span class="comment">% the true moment of threshold crossing and (2) the threshold crossing</span>
0015 <span class="comment">% is susceptible to noise. So we use alignment in order to compare spikes</span>
0016 <span class="comment">% aligned on their maximum negative deviation from 0.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% Alignment is performed on the channel with the largest deviation and then</span>
0019 <span class="comment">% this offset is applied to all other channels.</span>
0020 <span class="comment">%</span>
0021 
0022     <span class="comment">% Check for previous alignment</span>
0023     <span class="keyword">if</span> isfield( spikes.info, <span class="string">'align'</span> )
0024         disp(<span class="string">'Spike data is already aligned.'</span>)
0025     <span class="keyword">else</span>
0026 
0027         <span class="comment">% make helper variables</span>
0028         w = spikes.waveforms;
0029         num_spikes     = size(w,1);
0030         num_samples    = size(w,2);
0031         num_channels   = size(w,3);
0032         max_samples    = round(spikes.params.max_jitter(1) * spikes.params.Fs(1)/1000);
0033         keep_samples = num_samples-max_samples;
0034         thresh_sample  = spikes.info.detect.align_sample;
0035         thresh_channel = spikes.info.detect.event_channel;
0036 
0037         <span class="comment">% build a matrix of only the waveforms that triggered spike detection</span>
0038         w2  = zeros( [num_spikes num_samples] );    
0039         <span class="keyword">for</span> j = 1:num_spikes
0040             w2( j, : ) = w(j,:,thresh_channel(j));
0041         <span class="keyword">end</span>
0042 
0043         <span class="comment">% find alignment point on the triggered channel</span>
0044         shifts = <a href="#_sub1" class="code" title="subfunction shifts = get_offsets( w2, thresh_sample, max_samples )">get_offsets</a>( w2, thresh_sample, max_samples );  
0045 
0046         <span class="comment">% apply alignment to all channels</span>
0047         <span class="keyword">for</span> j = 1:num_channels
0048             spikes.waveforms(:,1:keep_samples,j) = <a href="#_sub2" class="code" title="subfunction new_w = respline(w,  shifts, max_s)">respline</a>( w(:,:,j), shifts, max_samples );
0049         <span class="keyword">end</span>
0050         spikes.waveforms(:,keep_samples+1:<span class="keyword">end</span>,:) = [];
0051 
0052         <span class="comment">% update spike times</span>
0053         spikes.spiketimes = spikes.spiketimes + shifts' / spikes.params.Fs(1);
0054 
0055         <span class="comment">% update alignment flagged</span>
0056         spikes.info.align.aligned = 1;
0057     <span class="keyword">end</span>
0058 
0059     [pca.u,pca.s,pca.v] = svd(detrend(spikes.waveforms(:,:),<span class="string">'constant'</span>), 0);             <span class="comment">% SVD the data matrix</span>
0060     spikes.info.pca = pca;
0061         
0062 <span class="comment">%</span>
0063 <span class="comment">%  HELPER FUNCTIONS</span>
0064 <span class="comment">%</span>
0065   
0066  <a name="_sub1" href="#_subfunctions" class="code">function shifts = get_offsets( w2, thresh_sample, max_samples )</a>
0067  <span class="comment">% find the alignment point in a matrix of data</span>
0068  
0069     num_spikes = size(w2,1);
0070     num_samples = size(w2,2);
0071     
0072     <span class="comment">% get spline coefficients for region of interest</span>
0073     pp = spline( 1:num_samples, w2 );
0074     coefs = reshape( pp.coefs, [num_spikes,num_samples-1,4] );
0075     ind  = thresh_sample + -2 + [1:max_samples];
0076     a = coefs(:,ind,1)';  b = coefs(:,ind,2)';  c = coefs(:,ind,3)'; d =coefs(:,ind,4)';
0077     
0078     <span class="comment">% find value at positive peak, negative peak, and edge</span>
0079     p = ( -b + sqrt(b.^2 - 3*a.*c) ) ./ (3*a);
0080     n = ( -b - sqrt(b.^2 - 3*a.*c) ) ./ (3*a);
0081     val1 = a.*(p.^3) + b.*(p.^2) + c.*p + d;    
0082     val2 = a.*(n.^3) + b.*(n.^2) + c.*n + d;
0083     val3 = w2(:,ind+1)';
0084     
0085     <span class="comment">% strike out values found out of range or that are complex</span>
0086     val1( p&lt;0 | p&gt;1 | imag(p)~=0 ) = inf;
0087     val2( n&lt;0 | n&gt;1 | imag(n)~=0 ) = inf;
0088      
0089     <span class="comment">% find best in each category</span>
0090     [val11, pos11] = min(val1,[],1);
0091     [val22, pos22] = min(val2,[],1);
0092     [val33, pos33] = min(val3,[],1);
0093     
0094     <span class="comment">% find best overall</span>
0095     [val,pos] = min( [val11' val22' val33' ]',[],1 );
0096     
0097     <span class="comment">% save the peak locations</span>
0098     peak_loc = zeros([num_spikes 1 ]);
0099     <span class="keyword">for</span> j = 1:length(pos)
0100         <span class="keyword">if</span>      pos(j)==1, peak_loc(j) = ind(pos11(j)) + p(pos11(j),j);
0101         <span class="keyword">elseif</span>  pos(j)==2, peak_loc(j) = ind(pos22(j)) + n(pos22(j),j);
0102         <span class="keyword">elseif</span>  pos(j)==3, peak_loc(j) = pos33(j) + thresh_sample - 2;
0103         <span class="keyword">end</span>
0104     <span class="keyword">end</span>
0105     shifts = peak_loc - thresh_sample;
0106        
0107     
0108 <a name="_sub2" href="#_subfunctions" class="code">function new_w = respline(w,  shifts, max_s)  </a>
0109 <span class="comment">% generate values around new alignment point using spline interpolation</span>
0110 
0111    num_spikes = size(w,1);
0112    num_samples = size(w,2);
0113    total_samples = num_samples-max_s;
0114    
0115    pp = spline(1:num_samples, w);
0116    
0117    <span class="comment">% the efficient way to call spline is on a single vector rather than</span>
0118    <span class="comment">% on a stack.  so we are going to concatenate all the waveforms together</span>
0119    <span class="comment">% with zeros in between</span>
0120    pp.coefs = reshape(pp.coefs, num_spikes, num_samples-1, []);
0121    pp.coefs = permute(pp.coefs, [2 1 3]);
0122    padzeros = zeros(1,num_spikes, 4);
0123    pp.coefs = cat(1, pp.coefs, padzeros);
0124    pp.coefs(num_samples,:,4) = w(:,end)';
0125    pp.coefs = reshape(pp.coefs, [], 4);
0126    pp.pieces = num_spikes*num_samples;   
0127    pp.dim = 1;   
0128    pp.breaks = [1:(pp.pieces+1)];
0129   
0130    <span class="comment">% get  indices for new waveforms</span>
0131   
0132    shift_mat = repmat( shifts,1, total_samples );
0133    offset    = repmat(([1:num_spikes]-1)' * num_samples, 1,total_samples); 
0134    ind_mat   = repmat( [1:total_samples], num_spikes, 1 );
0135    new_inds  = offset + shift_mat + ind_mat;
0136  
0137    <span class="comment">% evaluate spline at the locations of the new waveforms</span>
0138    new_w = ppval(pp, new_inds);</pre></div>
<hr><address>Generated on Thu 11-Jul-2013 10:16:49 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>